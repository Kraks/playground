-- Chapter 5

theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     apply hp
     apply And.intro
     exact hq
     exact hp

theorem test' (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp

theorem test'' (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right => exact And.intro hq hp
  case left => exact hp

-- use `.` to structure sub-proofs:

theorem test''' (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp

example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro ⟨hp, hqr⟩
    apply Or.elim hqr
    . intro hq
      apply Or.inl
      apply And.intro hp hq
    . intro hr
      apply Or.inr
      apply And.intro hp hr
  . intro h
    apply Or.elim h
    . intro ⟨hp, hq⟩
      apply And.intro hp (Or.inl hq)
    . intro ⟨hp, hr⟩
      apply And.intro hp (Or.inr hr)

example (α : Type) (p q : α → Prop) :
  (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ => exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ => exact ⟨w, Or.inl h⟩

-- assumption will unify metavariables
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) :
  x = w := by
  apply Eq.trans
  assumption
  apply Eq.trans
  assumption
  assumption

-- names automatically generated by Lean at not accessible by default.
-- Use `unhygienic` to access them.

example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1

-- `rename_i` renames inaccessible names into context

example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1

-- repeat

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption

-- `revert` also reverts the hypotheses depending on the reverted variable

example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption

-- `generalize` replaces a term to a fresh variable

example : 3 = 3 := by
  generalize 3 = x
  exact Eq.refl x

example (p : Prop) : p ∨ p → p := by
  intro h
  cases h <;> assumption

example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq => constructor; exact hq; exact hp

example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px => constructor; apply Or.inl; exact px

open Nat
example (P : Nat → Prop) (h₀ : P 0)
        (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    => exact h₀
  | succ m' => exact h₁ m'

-- combine `intro` with pattern matching
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
    | ⟨hp, Or.inl hq⟩ => apply Or.inl; constructor <;> assumption
    | ⟨hp, Or.inr hr⟩ => apply Or.inr; constructor <;> assumption
  . intro
    | Or.inl ⟨hp, hq⟩ => constructor; assumption; apply Or.inl; assumption
    | Or.inr ⟨hp, hr⟩ => constructor; assumption; apply Or.inr; assumption

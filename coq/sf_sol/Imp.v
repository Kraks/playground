Set Warnings "-notation-overridden,-parsing".
Require Import Coq.Bool.Bool.
Require Import Coq.Arith.Arith.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Maps.

Module AExp.

Inductive aexp : Type :=
  | ANum : nat -> aexp
  | APlus : aexp -> aexp -> aexp
  | AMinus : aexp -> aexp -> aexp
  | AMult : aexp -> aexp -> aexp.

Inductive bexp : Type :=
  | BTrue : bexp
  | BFalse : bexp
  | BEq : aexp -> aexp -> bexp
  | BLe : aexp -> aexp -> bexp
  | BNot : bexp -> bexp
  | BAnd : bexp -> bexp -> bexp.
  
(* Evaluation *)
  
Fixpoint aeval (a : aexp) : nat :=
match a with 
  | ANum n => n
  | APlus a1 a2 => (aeval a1) + (aeval a2)
  | AMinus a1 a2 => (aeval a1) - (aeval a2)
  | AMult a1 a2 => (aeval a1) * (aeval a2)
end.

Fixpoint beval (b : bexp) : bool :=
match b with
  | BTrue => true
  | BFalse => false
  | BEq a1 a2 => beq_nat (aeval a1) (aeval a2)
  | BLe a1 a2 => leb (aeval a1) (aeval a2)
  | BNot b1 => negb (beval b1)
  | BAnd b1 b2 => andb (beval b1) (beval b2)
end.

Fixpoint optimize_0plus (a : aexp) : aexp :=
match a with
| ANum n => ANum n
| APlus (ANum 0) e2 =>
  optimize_0plus e2
| APlus e1 e2 =>
  APlus (optimize_0plus e1) (optimize_0plus e2)
| AMinus e1 e2 =>
  AMinus (optimize_0plus e1) (optimize_0plus e2)
| AMult e1 e2 =>
  AMult (optimize_0plus e1) (optimize_0plus e2)
end.

Example test_optimize_0plus:
  optimize_0plus (APlus (ANum 2)
                        (APlus (ANum 0)
                               (APlus (ANum 0) (ANum 1))))
  = APlus (ANum 2) (ANum 1).
Proof. simpl. reflexivity. Qed.

Theorem optimize_0plus_sound : forall a, aeval (optimize_0plus a) = aeval a.
Proof.
  intros. induction a.
  - simpl. reflexivity.
  - destruct a1.
    * destruct n.
      + simpl. apply IHa2.
      + simpl. apply f_equal. rewrite IHa2. reflexivity.
    * simpl. simpl in IHa1. rewrite IHa1. rewrite IHa2. reflexivity.
    * simpl. simpl in IHa1. rewrite IHa1. rewrite IHa2. reflexivity.
    * simpl. simpl in IHa1. rewrite IHa1. rewrite IHa2. reflexivity.
  - simpl. rewrite IHa1. rewrite IHa2. reflexivity.
  - simpl. rewrite IHa1. rewrite IHa2. reflexivity.
Qed.

(* Coq Automation *)

(* Try *)

Theorem silly1 : forall ae, aeval ae = aeval ae.
Proof. try reflexivity. Qed.

Theorem silly2 : forall (P : Prop), P -> P.
Proof.
  intros.
  try reflexivity.
  apply H.
Qed.

(* The ; Tactical (Simple Form) *)

Lemma foo : forall n, leb 0 n = true.
Proof.
  intros.
  destruct n; simpl; reflexivity.
Qed.

Theorem optimize_0plus_sound': forall a, aeval (optimize_0plus a) = aeval a.
Proof.
  intros. induction a;
  try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).
  - reflexivity.
  - destruct a1;
    try (simpl; simpl in IHa1; rewrite IHa1; rewrite IHa2; reflexivity).
    + destruct n; simpl; rewrite IHa2; reflexivity.
Qed.

Theorem optimize_0plus_sound'': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros. induction a;
  try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);
  try reflexivity.
  - destruct a1; try (simpl; simpl in IHa1; rewrite IHa1; rewrite IHa2; 
                      reflexivity).
    + destruct n; simpl; rewrite IHa2; reflexivity.
Qed.

(* The ; Tactical (General Form) *)

(* T; [T1 | T2 | ... | Tn] 
   is a tactic that first performs T and then performs T1 on the first
   subgoal generated by T, performs T2 on the second subgoal, etc. *)

(* The repeat Tactical *)

Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  repeat (try (left; reflexivity); right).
Qed.

Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  repeat (left; reflexivity).
  repeat (right; (try (left; reflexivity))).
Qed.

(* Exercise *)

Fixpoint optimize_0plus_b (b : bexp) : bexp :=
  match b with
  | BTrue => BTrue
  | BFalse => BFalse
  | BEq x y => BEq (optimize_0plus x) (optimize_0plus y)
  | BLe x y => BLe (optimize_0plus x) (optimize_0plus y)
  | BNot b => BNot (optimize_0plus_b b)
  | BAnd x y => BAnd (optimize_0plus_b x) (optimize_0plus_b y)
  end.

Theorem optimize_0plus_b_sound : forall b,
  beval (optimize_0plus_b b) = beval b.
Proof.
  intros. induction b;
  try (simpl; reflexivity).
  try simpl; rewrite optimize_0plus_sound;
      rewrite optimize_0plus_sound; reflexivity.
  try simpl; rewrite optimize_0plus_sound;
      rewrite optimize_0plus_sound; reflexivity.
  - simpl. rewrite IHb. reflexivity.
  - simpl. rewrite IHb1. rewrite IHb2. reflexivity.
Qed.

(* The omega Tactic *)

Example silly_presburger_example : forall m n o p,
  m + n <= n + o /\ o + 3 = p + 3 ->
  m <= p.
Proof. intros. omega. Qed.

(* A Few More Handy Tactics *)

(* clear H: Delete hypothesis H from the context.
   subst x
   subst
   rename ... into ...
   assumption
   contradiction
   constructor *)
 
(* Evaluation as a Relation *)

Module aevalR_first_try.

Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum : forall n, aevalR (ANum n) n
  | E_APlus : forall e1 e2 n1 n2,
    aevalR e1 n1 -> aevalR e2 n2 ->
    aevalR (APlus e1 e2) (n1 + n2)
  | E_AMinus : forall e1 e2 n1 n2,
    aevalR e1 n1 -> aevalR e2 n2 ->
    aevalR (AMinus e1 e2) (n1 - n1)
  | E_AMult : forall e1 e2 n1 n2,
    aevalR e1 n1 -> aevalR e2 n2 ->
    aevalR (AMult e1 e2) (n1 * n2).

Notation "e '\\' n" := (aevalR e n)
                       (at level 50, left associativity)
                       : type_scope.

End aevalR_first_try.

Reserved Notation "e '\\' n" (at level 50, left associativity).

Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum : forall n, (ANum n) \\ n
  | E_APlus : forall e1 e2 n1 n2,
    (e1 \\ n1) -> (e2 \\ n2) -> (APlus e1 e2) \\ (n1 + n2)
  | E_AMinus : forall e1 e2 n1 n2,
    (e1 \\ n1) -> (e2 \\ n2) -> (AMinus e1 e2) \\ (n1 - n2)
  | E_AMult : forall e1 e2 n1 n2,
    (e1 \\ n1) -> (e2 \\ n2) -> (AMult e1 e2) \\ (n1 * n2)
  where "e '\\' n" := (aevalR e n) : type_scope.

Inductive S : Type :=
  | cons : Set -> S.

(* Equivalence of the Definitions *)

Theorem aeval_iff_aevalR : forall a n, (a \\ n) <-> aeval a = n.
Proof.
  split.
  - intros. induction H; simpl.
    + reflexivity.
    + rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
    + rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
    + rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
  - generalize dependent n.
    induction a; simpl; intros; subst.
    + apply E_ANum.
    + apply E_APlus.
      * apply IHa1. reflexivity.
      * apply IHa2. reflexivity.
    + apply E_AMinus.
      * apply IHa1. reflexivity.
      * apply IHa2. reflexivity.
    + apply E_AMult.
      * apply IHa1. reflexivity.
      * apply IHa2. reflexivity.
Qed.

Inductive bevalR : bexp -> bool -> Prop :=
  | E_BTrue : BTrue \\ true
  | E_BFalse : BFalse \\ false
  | E_BEq : forall e1 e2 n1 n2, 
    (aevalR e1 n1) -> (aevalR e2 n2) -> (BEq e1 e2) \\ beq_nat n1 n2
  | E_BLe : forall e1 e2 n1 n2,
    (aevalR e1 n1) -> (aevalR e2 n2) -> (BLe e1 e2) \\ leb n1 n2
  | E_BNot : forall e1 b1,
    (e1 \\ b1) -> (BNot e1) \\ negb b1
  | E_BAnd : forall e1 e2 b1 b2,
    (e1 \\ b1) -> (e2 \\ b2) -> (BAnd e1 e2) \\ (andb b1 b2)
  where "e '\\' b" := (bevalR e b) : type_scope.

Theorem beval_iff_bevalR : forall b bv,
  bevalR b bv <-> beval b = bv.
Proof.
  split.
  - intros. induction H; simpl.
    + reflexivity.
    + reflexivity.
    + apply aeval_iff_aevalR in H. apply aeval_iff_aevalR in H0.
      rewrite H. rewrite H0.
      reflexivity.
    + apply aeval_iff_aevalR in H. apply aeval_iff_aevalR in H0.
      rewrite H. rewrite H0.
      reflexivity.
    + subst. reflexivity.
    + subst. reflexivity.
  - generalize dependent bv.
    induction b; simpl; intros; subst.
    + apply E_BTrue.
    + apply E_BFalse.
    + apply E_BEq.
      * apply aeval_iff_aevalR. reflexivity.
      * apply aeval_iff_aevalR. reflexivity.
    + apply E_BLe.
      * apply aeval_iff_aevalR. reflexivity.
      * apply aeval_iff_aevalR. reflexivity.
    + apply E_BNot.
      apply IHb. reflexivity.
    + apply E_BAnd.
      * apply IHb1. reflexivity.
      * apply IHb2. reflexivity.
Qed.

End AExp.

(* Computational vs. Relation Definitions *)

Module aevalR_division.

Inductive aexp : Type :=
  | ANum : nat -> aexp 
  | APlus : aexp -> aexp -> aexp 
  | AMinus : aexp -> aexp -> aexp 
  | AMult : aexp -> aexp -> aexp 
  | ADiv : aexp -> aexp -> aexp.

Reserved Notation "e '\\' n" (at level 50, left associativity).

Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum : forall (n:nat),
      (ANum n) \\ n
  | E_APlus : forall (a1 a2: aexp) (n1 n2 : nat),
      (a1 \\ n1) -> (a2 \\ n2) -> (APlus a1 a2) \\ (n1 + n2)
  | E_AMinus : forall (a1 a2: aexp) (n1 n2 : nat),
      (a1 \\ n1) -> (a2 \\ n2) -> (AMinus a1 a2) \\ (n1 - n2)
  | E_AMult :  forall (a1 a2: aexp) (n1 n2 : nat),
      (a1 \\ n1) -> (a2 \\ n2) -> (AMult a1 a2) \\ (n1 * n2)
  | E_ADiv :  forall (a1 a2: aexp) (n1 n2 n3: nat),
      (a1 \\ n1) -> (a2 \\ n2) -> (n2 > 0) ->
      (mult n2 n3 = n1) -> (ADiv a1 a2) \\ n3

where "a '\\' n" := (aevalR a n) : type_scope.

End aevalR_division.

(* TODO aevalR_extended. *)

(* Expressions with Variables *)

(* States *)

Definition state := total_map nat.

Definition empty_state : state := t_empty 0.

(* Syntax *)

Inductive aexp : Type :=
  | ANum : nat -> aexp
  | AId : id -> aexp
  | APlus : aexp -> aexp -> aexp
  | AMinus : aexp -> aexp -> aexp
  | AMult : aexp -> aexp -> aexp.

Definition W : id := Id "W".
Definition X : id := Id "X".
Definition Y : id := Id "Y".
Definition Z : id := Id "Z".

Inductive bexp : Type :=
  | BTrue : bexp
  | BFalse : bexp
  | BEq : aexp -> aexp -> bexp
  | BLe : aexp -> aexp -> bexp
  | BNot : bexp -> bexp
  | BAnd : bexp -> bexp -> bexp.

Fixpoint aeval (st : state) (a : aexp) : nat :=
  match a with
  | ANum n => n
  | AId x => st x
  | APlus a1 a2 => (aeval st a1) + (aeval st a2)
  | AMinus a1 a2 => (aeval st a1) - (aeval st a2)
  | AMult a1 a2 => (aeval st a1) * (aeval st a2)
end.

Fixpoint beval (st : state) (b : bexp) : bool :=
match b with
  | BTrue => true
  | BFalse => false
  | BEq a1 a2 => beq_nat (aeval st a1) (aeval st a2)
  | BLe a1 a2 => leb (aeval st a1) (aeval st a2)
  | BNot b1 => negb (beval st b1)
  | BAnd b1 b2 => andb (beval st b1) (beval st b2)
end.

Example aexp1 : aeval (t_update empty_state X 5)
                      (APlus (ANum 3) (AMult (AId X) (ANum 2))) = 13.
Proof.
  simpl. reflexivity.
Qed.

(* Commands *)

Inductive com : Type :=
  | CSkip : com
  | CAss : id -> aexp -> com
  | CSeq : com -> com -> com
  | CIf : bexp -> com -> com -> com
  | CWhile : bexp -> com -> com.

Notation "'SKIP'" :=
  CSkip.
Notation "x '::=' a" :=
  (CAss x a) (at level 60).
Notation "c1 ;; c2" :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation "'WHILE' b 'DO' c 'END'" :=
  (CWhile b c) (at level 80, right associativity).
Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  (CIf c1 c2 c3) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;;
  Y ::= ANum 1;;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);;
    Z ::= AMinus (AId Z) (ANum 1)
  END.

Reserved Notation "c1 '/' st '\\' st'"
                  (at level 40, st at level 39).

Inductive ceval : com -> state -> state -> Prop :=
  | E_Skip : forall st, SKIP / st \\ st
  | E_Ass : forall st a1 n x,
    aeval st a1 = n ->
    (x ::= a1) / st \\ (t_update st x n)
  | E_Seq : forall c1 c2 st st' st'',
    c1 / st \\ st' ->
    c2 / st' \\ st'' ->
    (c1 ;; c2) / st \\ st''
  | E_IfTrue : forall st st' b c1 c2,
    beval st b = true ->
    c1 / st \\ st' ->
    (IFB b THEN c1 ELSE c2 FI) / st \\ st'
  | E_IfFalse : forall st st' b c1 c2,
    beval st b = false ->
    c2 / st \\ st' ->
    (IFB b THEN c1 ELSE c2 FI) / st \\ st'
  | E_WhileFalse : forall b st c,
    beval st b = false ->
    (WHILE b DO c END) / st \\ st
  | E_WhileTrue : forall st st' st'' b c,
    beval st b = true ->
    c / st \\ st' ->
    (WHILE b DO c END) / st' \\ st'' ->
    (WHILE b DO c END) / st \\ st''
  where "c1 '/' st '\\' st'" := (ceval c1 st st').

Example ceval_example1 : 
  (X ::= ANum 2;;
   IFB BLe (AId X) (ANum 1)
     THEN Y ::= ANum 3
     ELSE Z ::= ANum 4
   FI)
  /  empty_state
  \\ (t_update (t_update empty_state X 2) Z 4).
Proof.
  eapply E_Seq.
  - apply E_Ass. reflexivity.
  - apply E_IfFalse.
    + simpl. reflexivity.
    + apply E_Ass. reflexivity.
Qed.

(* TODO Exercises *)

(* Determinism of Evaluation *)

Theorem ceval_dterministic : forall c st st1 st2,
  c / st \\ st1 ->
  c / st \\ st2 ->
  st1 = st2.
Proof.
  intros.
  generalize dependent st2.
  induction H; intros st2 E2; inversion E2; subst.
  - reflexivity.
  - reflexivity.
  - assert (EQ : st' = st'0).
    { apply IHceval1. apply H3. } 
    subst. apply IHceval2. apply H6.
  - apply IHceval. apply H7.
  - rewrite H in H6. inversion H6.
  - rewrite H in H6. inversion H6.
  - apply IHceval. apply H7.
  - reflexivity.
  - rewrite H in H2. inversion H2.
  - rewrite H in H6. inversion H6.
  - assert (EQ : st' = st'0).
    { apply IHceval1. apply H5. }
    apply IHceval2. subst. apply H8.
Qed.

(* Reasoning About Imp Programs *)

Definition plus2 : com :=
  X ::= (APlus (AId X) (ANum 2)).

Theorem plus2_spec : forall st n st',
  st X = n ->
  plus2 / st \\ st' ->
  st' X = n + 2.
Proof.
  intros.
  inversion H0.
  subst. simpl. apply t_update_eq.
Qed.

(* TODO Exercises *)
